class Solution:
    def orangesRotting(self, grid: List[List[int]]) -> int:
        n = len(grid)
        m = len(grid[0])

        q = []
        cnt = 0
        for i in range(n) :
            for j in range(m) :
                if grid[i][j] == 2 :
                    q.append((i,j))
                if grid[i][j] == 1 :
                    cnt += 1
        res = 0

        dx = (0, -1, 0, 1)
        dy = (-1, 0, 1, 0)        
        while q :
            l = len(q)
            flag = False 
            for i in range(l) :
                row, col = q.pop(0)
                for pos in range(4) :
                    x = row+dx[pos]
                    y = col+dy[pos]
                    if 0<=x<n and 0<=y<m and grid[x][y] == 1 :
                        grid[x][y] = 2
                        cnt -= 1
                        q.append((x,y))
                        flag = True 
            if flag == True :
                res += 1

        # for i in range(n) :
        #     for j in range(m) :
        #         if grid[i][j] == 1 :
        #             return -1

        if cnt != 0 :
            return -1
        return res
                
''' time complexity : O(n*m)            BFS
    space complexity : O(n*m)
'''


#############################################################################################################################################################################################

from collections import deque
class Solution:

    #Function to find minimum time required to rot all oranges. 
	def orangesRotting(self, grid):
	    n, m = len(grid), len(grid[0])
	    visited = [[0] * m for _ in range(n)]
		q = deque([])
		
		for i in range(n):
		    for j in range(m):
		        if grid[i][j] == 2:
		            visited[i][j] = 1
		            q.append((i, j, 0))
        
        cnt = 0
        d = (0, -1, 0, 1, 0)
        while q:

            row, col, t = q.popleft()
            cnt = max(cnt, t)
            
            
            for i in range(4):
                newRow, newCol = row + d[i], col + d[i+1]
                if 0<= newRow < n and 0<= newCol < m and grid[newRow][newCol] == 1 and not visited[newRow][newCol]:
                    q.append((newRow, newCol, t+1))
                    grid[newRow][newCol] = 2 
                    visited[newRow][newCol] = 1
            
        
        
        for i in range(n):
            for j in range(m):
                if grid[i][j] == 1: 
                    return -1 
                    
        return cnt


1. https://leetcode.com/problems/rotting-oranges/description/
2. https://www.geeksforgeeks.org/problems/rotten-oranges2536/1?utm_source=youtube&utm_medium=collab_striver_ytdescription&utm_campaign=rotten_oranges
